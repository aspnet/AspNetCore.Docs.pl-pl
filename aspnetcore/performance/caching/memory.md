---
title: Buforowanie w pamięci w ASP.NET Core
author: rick-anderson
description: Dowiedz się, jak buforować dane w pamięci w ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 19e8dc0ae4d5f8fd28d03d5be87c0b1bbf32d940
ms.sourcegitcommit: 04ad9cd26fcaa8bd11e261d3661f375f5f343cdc
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 02/10/2021
ms.locfileid: "100107223"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="73958-103">Buforowanie w pamięci w ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="73958-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="73958-104">Autorzy [Rick Anderson](https://twitter.com/RickAndMSFT), [Jan Luo](https://github.com/JunTaoLuo)i [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="73958-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="73958-105">[Wyświetl lub pobierz przykładowy kod](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([jak pobrać](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="73958-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="73958-106">Podstawowe informacje o buforowaniu</span><span class="sxs-lookup"><span data-stu-id="73958-106">Caching basics</span></span>

<span data-ttu-id="73958-107">Buforowanie może znacząco poprawić wydajność i skalowalność aplikacji przez zmniejszenie ilości pracy wymaganej do wygenerowania zawartości.</span><span class="sxs-lookup"><span data-stu-id="73958-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="73958-108">Buforowanie działa najlepiej w **przypadku rzadko używanych** danych.</span><span class="sxs-lookup"><span data-stu-id="73958-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="73958-109">Buforowanie tworzy kopię danych, która może być zwracana znacznie szybciej niż ze źródła.</span><span class="sxs-lookup"><span data-stu-id="73958-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="73958-110">Aplikacje powinny być zapisane i przetestowane w taki sposób, aby **nigdy nie** zależały od danych buforowanych.</span><span class="sxs-lookup"><span data-stu-id="73958-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="73958-111">ASP.NET Core obsługuje kilka różnych pamięci podręcznych.</span><span class="sxs-lookup"><span data-stu-id="73958-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="73958-112">Najprostsza pamięć podręczna jest oparta na [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="73958-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="73958-113">`IMemoryCache` Reprezentuje pamięć podręczną przechowywaną w pamięci serwera sieci Web.</span><span class="sxs-lookup"><span data-stu-id="73958-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="73958-114">Aplikacje działające w farmie serwerów (wiele serwerów) powinny zapewnić, że sesje są w trakcie korzystania z pamięci podręcznej w pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="73958-115">Sesje usługi Sticky Notes zapewniają, że kolejne żądania od klienta będą kierowane do tego samego serwera.</span><span class="sxs-lookup"><span data-stu-id="73958-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="73958-116">Na przykład usługa Azure Web Apps używa [routingu żądań aplikacji](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) do kierowania wszystkich kolejnych żądań do tego samego serwera.</span><span class="sxs-lookup"><span data-stu-id="73958-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="73958-117">Sesje inne niż nietrwałe w kolektywie serwerów sieci Web wymagają [rozproszonej pamięci podręcznej](distributed.md) , aby uniknąć problemów ze spójnością pamięci</span><span class="sxs-lookup"><span data-stu-id="73958-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="73958-118">W przypadku niektórych aplikacji rozproszonej pamięci podręcznej może obsługiwać większą skalowalność niż pamięć podręczna w pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="73958-119">Użycie rozproszonej pamięci podręcznej powoduje odciążenie pamięci podręcznej do procesu zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="73958-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="73958-120">Pamięć podręczna w pamięci może przechowywać dowolny obiekt.</span><span class="sxs-lookup"><span data-stu-id="73958-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="73958-121">Interfejs rozproszonej pamięci podręcznej jest ograniczony do `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="73958-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="73958-122">Magazyn w pamięci i rozproszonej pamięci podręcznej przechowuje elementy pamięci podręcznej jako pary klucz-wartość.</span><span class="sxs-lookup"><span data-stu-id="73958-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="73958-123">System. Runtime. buforowanie/elemencie MemoryCache</span><span class="sxs-lookup"><span data-stu-id="73958-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="73958-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([Pakiet NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) może być używany z:</span><span class="sxs-lookup"><span data-stu-id="73958-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="73958-125">.NET Standard 2,0 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="73958-126">Dowolna [implementacja platformy .NET](/dotnet/standard/net-standard#net-implementation-support) , która jest przeznaczona dla .NET Standard 2,0 lub nowszych.</span><span class="sxs-lookup"><span data-stu-id="73958-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="73958-127">Na przykład ASP.NET Core 2,0 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="73958-128">.NET Framework 4,5 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="73958-129">[Firma Microsoft. Extensions. buforowanie. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (opisana w tym artykule) jest zalecana w porównaniu ze względu na to, że jest `System.Runtime.Caching` / `MemoryCache` lepiej zintegrowana z ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="73958-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="73958-130">Na przykład `IMemoryCache` działa natywnie z [iniekcją ASP.NET Core zależności](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="73958-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="73958-131">Użyj `System.Runtime.Caching` / `MemoryCache` jako mostka zgodności podczas przenoszenia kodu z ASP.NET 4. x do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="73958-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="73958-132">Wskazówki dotyczące pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-132">Cache guidelines</span></span>

* <span data-ttu-id="73958-133">Kod powinien zawsze mieć opcję rezerwową, aby pobrać dane i **nie** zależał od dostępnej wartości w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="73958-134">Pamięć podręczna używa nieodpowiedniego zasobu, pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="73958-135">Ogranicz wzrost rozmiaru pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="73958-135">Limit cache growth:</span></span>
  * <span data-ttu-id="73958-136">**Nie** należy używać zewnętrznych danych wejściowych jako kluczy pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="73958-137">Użyj wygaśnięć, aby ograniczyć wzrost rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="73958-138">[Użyj SetSize, size i SizeLimit, aby ograniczyć rozmiar pamięci podręcznej](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="73958-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="73958-139">Środowisko uruchomieniowe ASP.NET Core **nie ogranicza rozmiaru** pamięci podręcznej na podstawie nacisku pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="73958-140">Aby ograniczyć rozmiar pamięci podręcznej, należy do dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="73958-141">Użyj IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="73958-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="73958-142">Użycie pamięci podręcznej pamięci *współużytkowanej* przed [iniekcją zależności](xref:fundamentals/dependency-injection) i wywołaniem `SetSize` , `Size` lub `SizeLimit` w celu ograniczenia rozmiaru pamięci podręcznej może spowodować niepowodzenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="73958-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="73958-143">Po ustawieniu limitu rozmiaru w pamięci podręcznej, wszystkie wpisy muszą określać rozmiar podczas dodawania.</span><span class="sxs-lookup"><span data-stu-id="73958-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="73958-144">Może to prowadzić do problemów, ponieważ deweloperzy mogą nie mieć pełnej kontroli nad używaniem udostępnionej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="73958-145">Na przykład Entity Framework Core używa udostępnionej pamięci podręcznej i nie określa rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="73958-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="73958-146">Jeśli aplikacja ustawi limit rozmiaru pamięci podręcznej i użyje EF Core, aplikacja zgłosi `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="73958-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="73958-147">W przypadku korzystania z `SetSize` , `Size` , lub `SizeLimit` do ograniczania pamięci podręcznej, należy utworzyć pojedynczą pamięć podręczną dla buforowania.</span><span class="sxs-lookup"><span data-stu-id="73958-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="73958-148">Aby uzyskać więcej informacji i zapoznać się z przykładem, zobacz [Używanie SetSize, size i SizeLimit w celu ograniczenia rozmiaru pamięci podręcznej](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="73958-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="73958-149">Udostępniona pamięć podręczna jest współdzielona przez inne struktury lub biblioteki.</span><span class="sxs-lookup"><span data-stu-id="73958-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="73958-150">Na przykład EF Core używa udostępnionej pamięci podręcznej i nie określa rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="73958-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="73958-151">Buforowanie w pamięci to *Usługa* , do której odwołuje się aplikacja przy użyciu [iniekcji zależności](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="73958-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="73958-152">Zażądaj `IMemoryCache` wystąpienia w konstruktorze:</span><span class="sxs-lookup"><span data-stu-id="73958-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="73958-153">Poniższy kod używa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) aby sprawdzić, czy czas znajduje się w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="73958-154">Jeśli czas nie jest buforowany, nowy wpis zostanie utworzony i dodany do pamięci podręcznej z [zestawem](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="73958-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="73958-155">`CacheKeys`Klasa jest częścią przykładu pobierania.</span><span class="sxs-lookup"><span data-stu-id="73958-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="73958-156">Bieżąca godzina i w pamięci podręcznej są wyświetlane:</span><span class="sxs-lookup"><span data-stu-id="73958-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="73958-157">Poniższy kod używa metody rozszerzenia [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) do buforowania danych dla względnego czasu bez tworzenia `MemoryCacheEntryOptions` obiektu.</span><span class="sxs-lookup"><span data-stu-id="73958-157">The following code uses the [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) extension method to cache data for a relative time without creating the `MemoryCacheEntryOptions` object.</span></span>
[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_set)]

<span data-ttu-id="73958-158">Buforowana `DateTime` wartość pozostaje w pamięci podręcznej, gdy istnieją żądania w określonym limicie czasu.</span><span class="sxs-lookup"><span data-stu-id="73958-158">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="73958-159">Poniższy kod używa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) i [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) do buforowania danych.</span><span class="sxs-lookup"><span data-stu-id="73958-159">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="73958-160">Następujący kod wywołuje [pobieranie](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) , aby pobrać buforowany czas:</span><span class="sxs-lookup"><span data-stu-id="73958-160">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="73958-161">Poniższy kod pobiera lub tworzy buforowany element z bezwzględnym wygaśnięciem:</span><span class="sxs-lookup"><span data-stu-id="73958-161">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="73958-162">W pamięci podręcznej zestaw elementów z przewijanym okresem ważności jest zagrożony przestarzałą.</span><span class="sxs-lookup"><span data-stu-id="73958-162">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="73958-163">Jeśli dostęp do niego jest możliwy częściej niż przedział czasu wygaśnięcia, element nigdy nie wygaśnie.</span><span class="sxs-lookup"><span data-stu-id="73958-163">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="73958-164">Połącz okresowe wygaśnięcie i bezwzględne wygaśnięcie w celu zagwarantowania, że element wygaśnie po upływie bezwzględnego czasu wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="73958-164">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="73958-165">Bezwzględne wygaśnięcie Ustawia górną granicę, jak długo element może być buforowany, przy jednoczesnym dopuszczeniu do wcześniejszego wygaśnięcia elementu, jeśli nie zostanie on żądany w przedziale czasu wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="73958-165">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="73958-166">Gdy są określone okresy ważności bezwzględne i przesuwania, wygasające są logiczne logicznie.</span><span class="sxs-lookup"><span data-stu-id="73958-166">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="73958-167">Jeśli przedział czasu wygaśnięcia *lub* bezwzględny czas wygaśnięcia, element zostanie wykluczony z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-167">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="73958-168">Poniższy kod pobiera lub tworzy buforowany element z przewinięciem *i* bezwzględnym okresem ważności:</span><span class="sxs-lookup"><span data-stu-id="73958-168">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="73958-169">Poprzedni kod gwarantuje, że dane nie będą przechowywane w pamięci podręcznej dłużej niż czas bezwzględny.</span><span class="sxs-lookup"><span data-stu-id="73958-169">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="73958-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> , i <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> są metodami rozszerzającymi w <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> klasie.</span><span class="sxs-lookup"><span data-stu-id="73958-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="73958-171">Te metody zwiększają możliwości programu <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="73958-171">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="73958-172">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="73958-172">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="73958-173">Poniższy przykład:</span><span class="sxs-lookup"><span data-stu-id="73958-173">The following sample:</span></span>

* <span data-ttu-id="73958-174">Ustawia czas wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="73958-174">Sets a sliding expiration time.</span></span> <span data-ttu-id="73958-175">Żądania, które uzyskują dostęp do tego elementu w pamięci podręcznej, spowodują zresetowanie zegara zakończenia przewijania.</span><span class="sxs-lookup"><span data-stu-id="73958-175">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="73958-176">Ustawia priorytet pamięci podręcznej na [CacheItemPriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="73958-176">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="73958-177">Ustawia [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , który zostanie wywołany po wykluczeniu wpisu z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-177">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="73958-178">Wywołanie zwrotne jest uruchamiane w innym wątku niż kod, który usuwa element z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-178">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="73958-179">Użyj SetSize, size i SizeLimit, aby ograniczyć rozmiar pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-179">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="73958-180">`MemoryCache`Wystąpienie może opcjonalnie określić i wymusić limit rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="73958-180">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="73958-181">Limit rozmiaru pamięci podręcznej nie ma zdefiniowanej jednostki miary, ponieważ pamięć podręczna nie ma mechanizmu mierzenia rozmiaru wpisów.</span><span class="sxs-lookup"><span data-stu-id="73958-181">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="73958-182">Jeśli ustawiono limit rozmiaru pamięci podręcznej, wszystkie wpisy muszą określać rozmiar.</span><span class="sxs-lookup"><span data-stu-id="73958-182">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="73958-183">Środowisko uruchomieniowe ASP.NET Core nie ogranicza rozmiaru pamięci podręcznej na podstawie nacisku pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-183">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="73958-184">Aby ograniczyć rozmiar pamięci podręcznej, należy do dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-184">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="73958-185">Określony rozmiar jest w jednostkach wybranych przez dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-185">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="73958-186">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="73958-186">For example:</span></span>

* <span data-ttu-id="73958-187">Jeśli aplikacja sieci Web była przede wszystkim buforowania ciągów, każdy rozmiar wpisu pamięci podręcznej może być długością ciągu.</span><span class="sxs-lookup"><span data-stu-id="73958-187">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="73958-188">Aplikacja może określić rozmiar wszystkich wpisów jako 1, a limit rozmiaru to liczba wpisów.</span><span class="sxs-lookup"><span data-stu-id="73958-188">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="73958-189">Jeśli <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> nie jest ustawiona, pamięć podręczna rośnie bez powiązania.</span><span class="sxs-lookup"><span data-stu-id="73958-189">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="73958-190">Środowisko uruchomieniowe ASP.NET Core nie przycina pamięci podręcznej, gdy ilość pamięci systemowej jest niska.</span><span class="sxs-lookup"><span data-stu-id="73958-190">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="73958-191">Aplikacje muszą być zaprojektowane w celu:</span><span class="sxs-lookup"><span data-stu-id="73958-191">Apps must be architected to:</span></span>

* <span data-ttu-id="73958-192">Ogranicz wzrost rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-192">Limit cache growth.</span></span>
* <span data-ttu-id="73958-193">Połączenie <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> lub <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Jeśli dostępna pamięć jest ograniczona:</span><span class="sxs-lookup"><span data-stu-id="73958-193">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="73958-194">Poniższy kod tworzy bezjednostkowy rozmiar <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> dostępny w ramach [iniekcji zależności](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="73958-194">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="73958-195">`SizeLimit` nie ma jednostek.</span><span class="sxs-lookup"><span data-stu-id="73958-195">`SizeLimit` does not have units.</span></span> <span data-ttu-id="73958-196">Wpisy w pamięci podręcznej muszą określać rozmiar w jednostkach, które są uważane za najbardziej odpowiednie, jeśli ustawiono limit rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-196">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="73958-197">Wszyscy użytkownicy wystąpienia pamięci podręcznej powinni używać tego samego systemu jednostek.</span><span class="sxs-lookup"><span data-stu-id="73958-197">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="73958-198">Wpis nie zostanie zapisany w pamięci podręcznej, jeśli suma rozmiarów buforowanych wpisów przekroczy wartość określoną przez `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="73958-198">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="73958-199">Jeśli limit rozmiaru pamięci podręcznej nie zostanie ustawiony, rozmiar pamięci podręcznej ustawiony na wpis zostanie zignorowany.</span><span class="sxs-lookup"><span data-stu-id="73958-199">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="73958-200">Poniższy kod rejestruje `MyMemoryCache` z kontenerem [iniekcji zależności](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="73958-200">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="73958-201">`MyMemoryCache` jest tworzony jako pamięć podręczna niezależna pamięci dla składników, które są świadome pamięci podręcznej ograniczonej rozmiaru i wiedzą, jak ustawić odpowiednio rozmiar wpisu pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-201">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="73958-202">Następujący kod używa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="73958-202">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="73958-203">Rozmiar wpisu pamięci podręcznej może być ustawiony przez <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> lub <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> metody rozszerzenia:</span><span class="sxs-lookup"><span data-stu-id="73958-203">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="73958-204">Elemencie MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="73958-204">MemoryCache.Compact</span></span>

<span data-ttu-id="73958-205">`MemoryCache.Compact` próbuje usunąć określony procent pamięci podręcznej w następującej kolejności:</span><span class="sxs-lookup"><span data-stu-id="73958-205">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="73958-206">Wszystkie elementy wygasłe.</span><span class="sxs-lookup"><span data-stu-id="73958-206">All expired items.</span></span>
* <span data-ttu-id="73958-207">Elementy według priorytetu.</span><span class="sxs-lookup"><span data-stu-id="73958-207">Items by priority.</span></span> <span data-ttu-id="73958-208">Elementy o najniższym priorytecie są usuwane jako pierwsze.</span><span class="sxs-lookup"><span data-stu-id="73958-208">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="73958-209">Ostatnio używane obiekty.</span><span class="sxs-lookup"><span data-stu-id="73958-209">Least recently used objects.</span></span>
* <span data-ttu-id="73958-210">Elementy z najwcześniejszym bezwzględnym okresem ważności.</span><span class="sxs-lookup"><span data-stu-id="73958-210">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="73958-211">Elementy z najwcześniejszym okresem ważności.</span><span class="sxs-lookup"><span data-stu-id="73958-211">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="73958-212">Przypięte elementy z priorytetem <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nigdy nie są usuwane.</span><span class="sxs-lookup"><span data-stu-id="73958-212">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="73958-213">Poniższy kod usuwa element pamięci podręcznej i wywołuje `Compact` :</span><span class="sxs-lookup"><span data-stu-id="73958-213">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="73958-214">Aby uzyskać więcej informacji, zobacz artykuł [Compact Source w witrynie GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="73958-214">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="73958-215">Zależności pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-215">Cache dependencies</span></span>

<span data-ttu-id="73958-216">Poniższy przykład pokazuje, jak wygasa wpis pamięci podręcznej, Jeśli wpis zależny wygaśnie.</span><span class="sxs-lookup"><span data-stu-id="73958-216">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="73958-217"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Element jest dodawany do elementu w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-217">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="73958-218">Gdy `Cancel` jest wywoływana w `CancellationTokenSource` , oba wpisy pamięci podręcznej są wykluczone.</span><span class="sxs-lookup"><span data-stu-id="73958-218">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="73958-219">Użycie a <xref:System.Threading.CancellationTokenSource> umożliwia wykluczenie wielu wpisów pamięci podręcznej jako grupy.</span><span class="sxs-lookup"><span data-stu-id="73958-219">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="73958-220">Ze `using` wzorcem w powyższym kodzie wpisy pamięci podręcznej utworzone wewnątrz `using` bloku będą dziedziczyć wyzwalacze i ustawienia wygasania.</span><span class="sxs-lookup"><span data-stu-id="73958-220">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="73958-221">Uwagi dodatkowe</span><span class="sxs-lookup"><span data-stu-id="73958-221">Additional notes</span></span>

* <span data-ttu-id="73958-222">Wygaśnięcie nie odbywa się w tle.</span><span class="sxs-lookup"><span data-stu-id="73958-222">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="73958-223">Nie ma czasomierza, który aktywnie skanuje pamięć podręczną pod kątem wygasłych elementów.</span><span class="sxs-lookup"><span data-stu-id="73958-223">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="73958-224">Wszystkie działania w pamięci podręcznej ( `Get` , `Set` , `Remove` ) mogą wyzwalać skanowanie w tle dla elementów, które utraciły ważność.</span><span class="sxs-lookup"><span data-stu-id="73958-224">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="73958-225">Czasomierz w `CancellationTokenSource` ( <xref:System.Threading.CancellationTokenSource.CancelAfter*> ) również usuwa wpis i wyzwala skanowanie pod kątem wygasłych elementów.</span><span class="sxs-lookup"><span data-stu-id="73958-225">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and triggers a scan for expired items.</span></span> <span data-ttu-id="73958-226">W poniższym przykładzie zastosowano [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) dla zarejestrowanego tokenu.</span><span class="sxs-lookup"><span data-stu-id="73958-226">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="73958-227">Gdy ten token wyzwala, usuwa wpis natychmiast i wyzwala wywołania zwrotne wykluczenia:</span><span class="sxs-lookup"><span data-stu-id="73958-227">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="73958-228">W przypadku użycia wywołania zwrotnego do ponownego wypełnienia elementu pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="73958-228">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="73958-229">Wiele żądań może znaleźć pustą wartość klucza w pamięci podręcznej, ponieważ wywołanie zwrotne nie zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="73958-229">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="73958-230">Może to spowodować, że kilka wątków będzie przepełniać element w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-230">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="73958-231">Gdy jeden wpis pamięci podręcznej jest używany do utworzenia innego, element podrzędny kopiuje tokeny wygaśnięcia i czas wygaśnięcia na podstawie czasu.</span><span class="sxs-lookup"><span data-stu-id="73958-231">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="73958-232">Element podrzędny nie wygasł przez ręczne usunięcie lub aktualizację wpisu nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="73958-232">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="73958-233">Użyj, <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> Aby ustawić wywołania zwrotne, które będą wyzwalane po usunięciu wpisu pamięci podręcznej z tej pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-233">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="73958-234">W przypadku większości aplikacji `IMemoryCache` jest włączona.</span><span class="sxs-lookup"><span data-stu-id="73958-234">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="73958-235">Na przykład wywoływanie `AddMvc` , `AddControllersWithViews` , `AddRazorPages` , `AddMvcCore().AddRazorViewEngine` , i wiele innych `Add{Service}` metod w `ConfigureServices` , włącza `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="73958-235">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="73958-236">W przypadku aplikacji, które nie wywołuje jednej z powyższych `Add{Service}` metod, może być konieczne wywołanie metody <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="73958-236">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="73958-237">Aktualizacja pamięci podręcznej w tle</span><span class="sxs-lookup"><span data-stu-id="73958-237">Background cache update</span></span>

<span data-ttu-id="73958-238">Użyj [usługi w tle](xref:fundamentals/host/hosted-services) , takiej jak <xref:Microsoft.Extensions.Hosting.IHostedService> Aby zaktualizować pamięć podręczną.</span><span class="sxs-lookup"><span data-stu-id="73958-238">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="73958-239">Usługa w tle może ponownie obliczyć wpisy, a następnie przypisać je do pamięci podręcznej tylko wtedy, gdy są gotowe.</span><span class="sxs-lookup"><span data-stu-id="73958-239">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="73958-240">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="73958-240">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="73958-241">Autorzy [Rick Anderson](https://twitter.com/RickAndMSFT), [Jan Luo](https://github.com/JunTaoLuo)i [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="73958-241">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="73958-242">[Wyświetl lub pobierz przykładowy kod](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([jak pobrać](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="73958-242">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="73958-243">Podstawowe informacje o buforowaniu</span><span class="sxs-lookup"><span data-stu-id="73958-243">Caching basics</span></span>

<span data-ttu-id="73958-244">Buforowanie może znacząco poprawić wydajność i skalowalność aplikacji przez zmniejszenie ilości pracy wymaganej do wygenerowania zawartości.</span><span class="sxs-lookup"><span data-stu-id="73958-244">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="73958-245">Buforowanie działa najlepiej w przypadku rzadko używanych danych.</span><span class="sxs-lookup"><span data-stu-id="73958-245">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="73958-246">Buforowanie tworzy kopię danych, która może być zwracana znacznie szybciej niż z oryginalnego źródła.</span><span class="sxs-lookup"><span data-stu-id="73958-246">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="73958-247">Kod powinien być zapisany i przetestowany w taki sposób, aby **nigdy nie** zależał od danych buforowanych.</span><span class="sxs-lookup"><span data-stu-id="73958-247">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="73958-248">ASP.NET Core obsługuje kilka różnych pamięci podręcznych.</span><span class="sxs-lookup"><span data-stu-id="73958-248">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="73958-249">Najprostsza pamięć podręczna jest oparta na [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), która reprezentuje pamięć podręczną przechowywaną w pamięci serwera sieci Web.</span><span class="sxs-lookup"><span data-stu-id="73958-249">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="73958-250">Aplikacje działające w farmie serwerów (wiele serwerów) powinny mieć pewność, że sesje są w trakcie korzystania z pamięci podręcznej w pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-250">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="73958-251">Sesje usługi Sticky Notes zapewniają, że późniejsze żądania od klienta będą kierowane do tego samego serwera.</span><span class="sxs-lookup"><span data-stu-id="73958-251">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="73958-252">Na przykład usługa Azure Web Apps używa [routingu żądań aplikacji](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) do kierowania wszystkich żądań od agenta użytkownika na ten sam serwer.</span><span class="sxs-lookup"><span data-stu-id="73958-252">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="73958-253">Sesje inne niż nietrwałe w kolektywie serwerów sieci Web wymagają [rozproszonej pamięci podręcznej](distributed.md) , aby uniknąć problemów ze spójnością pamięci</span><span class="sxs-lookup"><span data-stu-id="73958-253">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="73958-254">W przypadku niektórych aplikacji rozproszonej pamięci podręcznej może obsługiwać większą skalowalność niż pamięć podręczna w pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-254">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="73958-255">Użycie rozproszonej pamięci podręcznej powoduje odciążenie pamięci podręcznej do procesu zewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="73958-255">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="73958-256">Pamięć podręczna w pamięci może przechowywać dowolny obiekt.</span><span class="sxs-lookup"><span data-stu-id="73958-256">The in-memory cache can store any object.</span></span> <span data-ttu-id="73958-257">Interfejs rozproszonej pamięci podręcznej jest ograniczony do `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="73958-257">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="73958-258">Magazyn w pamięci i rozproszonej pamięci podręcznej przechowuje elementy pamięci podręcznej jako pary klucz-wartość.</span><span class="sxs-lookup"><span data-stu-id="73958-258">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="73958-259">System. Runtime. buforowanie/elemencie MemoryCache</span><span class="sxs-lookup"><span data-stu-id="73958-259">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="73958-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([Pakiet NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) może być używany z:</span><span class="sxs-lookup"><span data-stu-id="73958-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="73958-261">.NET Standard 2,0 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-261">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="73958-262">Dowolna [implementacja platformy .NET](/dotnet/standard/net-standard#net-implementation-support) , która jest przeznaczona dla .NET Standard 2,0 lub nowszych.</span><span class="sxs-lookup"><span data-stu-id="73958-262">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="73958-263">Na przykład ASP.NET Core 2,0 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-263">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="73958-264">.NET Framework 4,5 lub nowszy.</span><span class="sxs-lookup"><span data-stu-id="73958-264">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="73958-265">[Firma Microsoft. Extensions. buforowanie. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (opisana w tym artykule) jest zalecana w porównaniu ze względu na to, że jest `System.Runtime.Caching` / `MemoryCache` lepiej zintegrowana z ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="73958-265">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="73958-266">Na przykład `IMemoryCache` działa natywnie z [iniekcją ASP.NET Core zależności](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="73958-266">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="73958-267">Użyj `System.Runtime.Caching` / `MemoryCache` jako mostka zgodności podczas przenoszenia kodu z ASP.NET 4. x do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="73958-267">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="73958-268">Wskazówki dotyczące pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-268">Cache guidelines</span></span>

* <span data-ttu-id="73958-269">Kod powinien zawsze mieć opcję rezerwową, aby pobrać dane i **nie** zależał od dostępnej wartości w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-269">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="73958-270">Pamięć podręczna używa nieodpowiedniego zasobu, pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-270">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="73958-271">Ogranicz wzrost rozmiaru pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="73958-271">Limit cache growth:</span></span>
  * <span data-ttu-id="73958-272">**Nie** należy używać zewnętrznych danych wejściowych jako kluczy pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-272">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="73958-273">Użyj wygaśnięć, aby ograniczyć wzrost rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-273">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="73958-274">[Użyj SetSize, size i SizeLimit, aby ograniczyć rozmiar pamięci podręcznej](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="73958-274">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="73958-275">Środowisko uruchomieniowe ASP.NET Core nie ogranicza rozmiaru pamięci podręcznej na podstawie nacisku pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-275">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="73958-276">Aby ograniczyć rozmiar pamięci podręcznej, należy do dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-276">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="73958-277">Korzystanie z IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="73958-277">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="73958-278">Użycie pamięci podręcznej pamięci *współużytkowanej* przed [iniekcją zależności](xref:fundamentals/dependency-injection) i wywołaniem `SetSize` , `Size` lub `SizeLimit` w celu ograniczenia rozmiaru pamięci podręcznej może spowodować niepowodzenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="73958-278">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="73958-279">Po ustawieniu limitu rozmiaru w pamięci podręcznej, wszystkie wpisy muszą określać rozmiar podczas dodawania.</span><span class="sxs-lookup"><span data-stu-id="73958-279">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="73958-280">Może to prowadzić do problemów, ponieważ deweloperzy mogą nie mieć pełnej kontroli nad używaniem udostępnionej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-280">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="73958-281">Na przykład Entity Framework Core używa udostępnionej pamięci podręcznej i nie określa rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="73958-281">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="73958-282">Jeśli aplikacja ustawi limit rozmiaru pamięci podręcznej i użyje EF Core, aplikacja zgłosi `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="73958-282">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="73958-283">W przypadku korzystania z `SetSize` , `Size` , lub `SizeLimit` do ograniczania pamięci podręcznej, należy utworzyć pojedynczą pamięć podręczną dla buforowania.</span><span class="sxs-lookup"><span data-stu-id="73958-283">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="73958-284">Aby uzyskać więcej informacji i zapoznać się z przykładem, zobacz [Używanie SetSize, size i SizeLimit w celu ograniczenia rozmiaru pamięci podręcznej](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="73958-284">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="73958-285">Buforowanie w pamięci to *Usługa* , do której odwołuje się aplikacja przy użyciu [iniekcji zależności](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="73958-285">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="73958-286">Wywołanie `AddMemoryCache` w `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="73958-286">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="73958-287">Zażądaj `IMemoryCache` wystąpienia w konstruktorze:</span><span class="sxs-lookup"><span data-stu-id="73958-287">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="73958-288">`IMemoryCache` wymaga pakietu NuGet [Microsoft. Extensions. buforowanie. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), który jest dostępny w [pakiecie Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="73958-288">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="73958-289">Poniższy kod używa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) aby sprawdzić, czy czas znajduje się w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-289">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="73958-290">Jeśli czas nie jest buforowany, nowy wpis zostanie utworzony i dodany do pamięci podręcznej z [zestawem](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="73958-290">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="73958-291">Bieżąca godzina i w pamięci podręcznej są wyświetlane:</span><span class="sxs-lookup"><span data-stu-id="73958-291">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="73958-292">Buforowana `DateTime` wartość pozostaje w pamięci podręcznej, gdy istnieją żądania w określonym limicie czasu.</span><span class="sxs-lookup"><span data-stu-id="73958-292">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="73958-293">Na poniższej ilustracji przedstawiono bieżący czas i wcześniejszy czas pobrany z pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="73958-293">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Widok indeksu z dwoma różnymi godzinami wyświetlania](memory/_static/time.png)

<span data-ttu-id="73958-295">Poniższy kod używa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) i [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) do buforowania danych.</span><span class="sxs-lookup"><span data-stu-id="73958-295">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="73958-296">Następujący kod wywołuje [pobieranie](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) , aby pobrać buforowany czas:</span><span class="sxs-lookup"><span data-stu-id="73958-296">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="73958-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> , i [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) są metodami rozszerzenia części klasy [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) , która rozszerza możliwości programu <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="73958-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="73958-298">Zobacz [metody IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) i [CacheExtensions metody](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) opisujące inne metody pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-298">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="73958-299">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="73958-299">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="73958-300">Poniższy przykład:</span><span class="sxs-lookup"><span data-stu-id="73958-300">The following sample:</span></span>

* <span data-ttu-id="73958-301">Ustawia czas wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="73958-301">Sets a sliding expiration time.</span></span> <span data-ttu-id="73958-302">Żądania, które uzyskują dostęp do tego elementu w pamięci podręcznej, spowodują zresetowanie zegara zakończenia przewijania.</span><span class="sxs-lookup"><span data-stu-id="73958-302">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="73958-303">Ustawia priorytet pamięci podręcznej na `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="73958-303">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="73958-304">Ustawia [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , który zostanie wywołany po wykluczeniu wpisu z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-304">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="73958-305">Wywołanie zwrotne jest uruchamiane w innym wątku niż kod, który usuwa element z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-305">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="73958-306">Użyj SetSize, size i SizeLimit, aby ograniczyć rozmiar pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-306">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="73958-307">`MemoryCache`Wystąpienie może opcjonalnie określić i wymusić limit rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="73958-307">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="73958-308">Limit rozmiaru pamięci podręcznej nie ma zdefiniowanej jednostki miary, ponieważ pamięć podręczna nie ma mechanizmu mierzenia rozmiaru wpisów.</span><span class="sxs-lookup"><span data-stu-id="73958-308">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="73958-309">Jeśli ustawiono limit rozmiaru pamięci podręcznej, wszystkie wpisy muszą określać rozmiar.</span><span class="sxs-lookup"><span data-stu-id="73958-309">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="73958-310">Środowisko uruchomieniowe ASP.NET Core nie ogranicza rozmiaru pamięci podręcznej na podstawie nacisku pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-310">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="73958-311">Aby ograniczyć rozmiar pamięci podręcznej, należy do dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-311">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="73958-312">Określony rozmiar jest w jednostkach wybranych przez dewelopera.</span><span class="sxs-lookup"><span data-stu-id="73958-312">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="73958-313">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="73958-313">For example:</span></span>

* <span data-ttu-id="73958-314">Jeśli aplikacja sieci Web była przede wszystkim buforowania ciągów, każdy rozmiar wpisu pamięci podręcznej może być długością ciągu.</span><span class="sxs-lookup"><span data-stu-id="73958-314">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="73958-315">Aplikacja może określić rozmiar wszystkich wpisów jako 1, a limit rozmiaru to liczba wpisów.</span><span class="sxs-lookup"><span data-stu-id="73958-315">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="73958-316">Jeśli <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> nie jest ustawiona, pamięć podręczna rośnie bez powiązania.</span><span class="sxs-lookup"><span data-stu-id="73958-316">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="73958-317">Środowisko uruchomieniowe ASP.NET Core nie przycina pamięci podręcznej, gdy ilość pamięci systemowej jest niska.</span><span class="sxs-lookup"><span data-stu-id="73958-317">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="73958-318">Aplikacje są w znacznym stopniu zaprojektowane pod kątem:</span><span class="sxs-lookup"><span data-stu-id="73958-318">Apps much be architected to:</span></span>

* <span data-ttu-id="73958-319">Ogranicz wzrost rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-319">Limit cache growth.</span></span>
* <span data-ttu-id="73958-320">Połączenie <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> lub <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> Jeśli dostępna pamięć jest ograniczona:</span><span class="sxs-lookup"><span data-stu-id="73958-320">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="73958-321">Poniższy kod tworzy bezjednostkowy rozmiar <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> dostępny w ramach [iniekcji zależności](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="73958-321">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="73958-322">`SizeLimit` nie ma jednostek.</span><span class="sxs-lookup"><span data-stu-id="73958-322">`SizeLimit` does not have units.</span></span> <span data-ttu-id="73958-323">Wpisy w pamięci podręcznej muszą określać rozmiar w jednostkach, które są uważane za najbardziej odpowiednie, jeśli ustawiono limit rozmiaru pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-323">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="73958-324">Wszyscy użytkownicy wystąpienia pamięci podręcznej powinni używać tego samego systemu jednostek.</span><span class="sxs-lookup"><span data-stu-id="73958-324">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="73958-325">Wpis nie zostanie zapisany w pamięci podręcznej, jeśli suma rozmiarów buforowanych wpisów przekroczy wartość określoną przez `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="73958-325">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="73958-326">Jeśli limit rozmiaru pamięci podręcznej nie zostanie ustawiony, rozmiar pamięci podręcznej ustawiony na wpis zostanie zignorowany.</span><span class="sxs-lookup"><span data-stu-id="73958-326">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="73958-327">Poniższy kod rejestruje `MyMemoryCache` z kontenerem [iniekcji zależności](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="73958-327">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="73958-328">`MyMemoryCache` jest tworzony jako pamięć podręczna niezależna pamięci dla składników, które są świadome pamięci podręcznej ograniczonej rozmiaru i wiedzą, jak ustawić odpowiednio rozmiar wpisu pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-328">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="73958-329">Następujący kod używa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="73958-329">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="73958-330">Rozmiar wpisu pamięci podręcznej można ustawić przez [rozmiar](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) lub metodę rozszerzenia [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="73958-330">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="73958-331">Elemencie MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="73958-331">MemoryCache.Compact</span></span>

<span data-ttu-id="73958-332">`MemoryCache.Compact` próbuje usunąć określony procent pamięci podręcznej w następującej kolejności:</span><span class="sxs-lookup"><span data-stu-id="73958-332">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="73958-333">Wszystkie elementy wygasłe.</span><span class="sxs-lookup"><span data-stu-id="73958-333">All expired items.</span></span>
* <span data-ttu-id="73958-334">Elementy według priorytetu.</span><span class="sxs-lookup"><span data-stu-id="73958-334">Items by priority.</span></span> <span data-ttu-id="73958-335">Elementy o najniższym priorytecie są usuwane jako pierwsze.</span><span class="sxs-lookup"><span data-stu-id="73958-335">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="73958-336">Ostatnio używane obiekty.</span><span class="sxs-lookup"><span data-stu-id="73958-336">Least recently used objects.</span></span>
* <span data-ttu-id="73958-337">Elementy z najwcześniejszym bezwzględnym okresem ważności.</span><span class="sxs-lookup"><span data-stu-id="73958-337">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="73958-338">Elementy z najwcześniejszym okresem ważności.</span><span class="sxs-lookup"><span data-stu-id="73958-338">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="73958-339">Przypięte elementy z priorytetem <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nigdy nie są usuwane.</span><span class="sxs-lookup"><span data-stu-id="73958-339">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="73958-340">Aby uzyskać więcej informacji, zobacz artykuł [Compact Source w witrynie GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="73958-340">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="73958-341">Zależności pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="73958-341">Cache dependencies</span></span>

<span data-ttu-id="73958-342">Poniższy przykład pokazuje, jak wygasa wpis pamięci podręcznej, Jeśli wpis zależny wygaśnie.</span><span class="sxs-lookup"><span data-stu-id="73958-342">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="73958-343"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Element jest dodawany do elementu w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-343">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="73958-344">Gdy `Cancel` jest wywoływana w `CancellationTokenSource` , oba wpisy pamięci podręcznej są wykluczone.</span><span class="sxs-lookup"><span data-stu-id="73958-344">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="73958-345">Użycie a `CancellationTokenSource` umożliwia wykluczenie wielu wpisów pamięci podręcznej jako grupy.</span><span class="sxs-lookup"><span data-stu-id="73958-345">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="73958-346">Ze `using` wzorcem w powyższym kodzie wpisy pamięci podręcznej utworzone wewnątrz `using` bloku będą dziedziczyć wyzwalacze i ustawienia wygasania.</span><span class="sxs-lookup"><span data-stu-id="73958-346">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="73958-347">Uwagi dodatkowe</span><span class="sxs-lookup"><span data-stu-id="73958-347">Additional notes</span></span>

* <span data-ttu-id="73958-348">W przypadku użycia wywołania zwrotnego do ponownego wypełnienia elementu pamięci podręcznej:</span><span class="sxs-lookup"><span data-stu-id="73958-348">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="73958-349">Wiele żądań może znaleźć pustą wartość klucza w pamięci podręcznej, ponieważ wywołanie zwrotne nie zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="73958-349">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="73958-350">Może to spowodować, że kilka wątków będzie przepełniać element w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="73958-350">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="73958-351">Gdy jeden wpis pamięci podręcznej jest używany do utworzenia innego, element podrzędny kopiuje tokeny wygaśnięcia i czas wygaśnięcia na podstawie czasu.</span><span class="sxs-lookup"><span data-stu-id="73958-351">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="73958-352">Element podrzędny nie wygasł przez ręczne usunięcie lub aktualizację wpisu nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="73958-352">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="73958-353">Użyj [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) , aby ustawić wywołania zwrotne, które zostaną wyzwolone po usunięciu wpisu pamięci podręcznej z pamięci.</span><span class="sxs-lookup"><span data-stu-id="73958-353">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="73958-354">Aktualizacja pamięci podręcznej w tle</span><span class="sxs-lookup"><span data-stu-id="73958-354">Background cache update</span></span>

<span data-ttu-id="73958-355">Użyj [usługi w tle](xref:fundamentals/host/hosted-services) , takiej jak <xref:Microsoft.Extensions.Hosting.IHostedService> Aby zaktualizować pamięć podręczną.</span><span class="sxs-lookup"><span data-stu-id="73958-355">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="73958-356">Usługa w tle może ponownie obliczyć wpisy, a następnie przypisać je do pamięci podręcznej tylko wtedy, gdy są gotowe.</span><span class="sxs-lookup"><span data-stu-id="73958-356">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="73958-357">Dodatkowe zasoby</span><span class="sxs-lookup"><span data-stu-id="73958-357">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
