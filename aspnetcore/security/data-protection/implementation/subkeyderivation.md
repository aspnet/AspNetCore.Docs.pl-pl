---
title: Wyprowadzanie podkluczy i uwierzytelnione szyfrowanie w ASP.NET Core
author: rick-anderson
description: Poznaj szczegóły implementacji wyprowadzenia podklucza ASP.NET Core ochrony danych i uwierzytelniania uwierzytelnionego.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- 'appsettings.json'
- 'ASP.NET Core Identity'
- 'cookie'
- 'Cookie'
- 'Blazor'
- 'Blazor Server'
- 'Blazor WebAssembly'
- 'Identity'
- "Let's Encrypt"
- 'Razor'
- 'SignalR'
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: efe8ad2f71feda9cbc1693d362e30eff29cbcd74
ms.sourcegitcommit: ca34c1ac578e7d3daa0febf1810ba5fc74f60bbf
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/30/2020
ms.locfileid: "93060160"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="4bcc4-103">Wyprowadzanie podkluczy i uwierzytelnione szyfrowanie w ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="4bcc4-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="4bcc4-104">Większość kluczy w pierścieniu kluczy będzie zawierać pewną postać entropii i będzie zawierać informacje o algorytmach z uwzględnieniem "CBC-Mode Encryption + HMAC Validation" lub "GCM Encryption + Validation".</span><span class="sxs-lookup"><span data-stu-id="4bcc4-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="4bcc4-105">W takich przypadkach odwołujemy się do osadzonej entropii jako głównego materiału klucza (lub KM) dla tego klucza i wykonujemy funkcję wyprowadzania klucza w celu uzyskania kluczy, które będą używane dla rzeczywistych operacji kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="4bcc4-106">Klucze są abstrakcyjne i implementacja niestandardowa może nie zachowywać się w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="4bcc4-107">Jeśli klucz stanowi własną implementację `IAuthenticatedEncryptor` zamiast korzystania z jednego z naszych wbudowanych fabryk, mechanizm opisany w tej sekcji już nie ma zastosowania.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="4bcc4-108">Dodatkowe uwierzytelnione dane i podklucze</span><span class="sxs-lookup"><span data-stu-id="4bcc4-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="4bcc4-109">`IAuthenticatedEncryptor`Interfejs służy jako podstawowy interfejs dla wszystkich uwierzytelnionych operacji szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="4bcc4-110">Jego `Encrypt` Metoda przyjmuje dwa bufory: zwykły tekst i additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="4bcc4-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="4bcc4-111">Zawartość w postaci zwykłego tekstu nie zmieniła się z wywołaniem `IDataProtector.Protect` , ale jest generowana przez system i składa się z trzech składników:</span><span class="sxs-lookup"><span data-stu-id="4bcc4-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="4bcc4-112">32-bitowy nagłówek Magic 09 F0 C9 F0, który identyfikuje tę wersję systemu ochrony danych.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="4bcc4-113">Identyfikator klucza 128-bitowego.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="4bcc4-114">Ciąg o zmiennej długości utworzony z łańcucha przeznaczenie, który utworzył tę `IDataProtector` operację.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="4bcc4-115">Ponieważ usługa AAD jest unikatowa dla krotki wszystkich trzech składników, możemy użyć jej do uzyskania nowych kluczy z KM zamiast używania kilometrów we wszystkich naszych operacjach kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="4bcc4-116">Dla każdego wywołania do programu `IAuthenticatedEncryptor.Encrypt` odbywa się następujący proces wyprowadzania klucza:</span><span class="sxs-lookup"><span data-stu-id="4bcc4-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="4bcc4-117">W tym miejscu wywołujemy instytut NIST SP800-108 KDF w trybie licznika (zobacz [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), s. 5,1) z następującymi parametrami:</span><span class="sxs-lookup"><span data-stu-id="4bcc4-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="4bcc4-118">Klucz wyprowadzania klucza (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="4bcc4-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="4bcc4-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="4bcc4-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="4bcc4-120">Etykieta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="4bcc4-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="4bcc4-121">Context = contextHeader | | Modyfikator</span><span class="sxs-lookup"><span data-stu-id="4bcc4-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="4bcc4-122">Nagłówek kontekstu ma zmienną długość i zasadniczo służy jako odcisk palca algorytmów, dla których są wyprowadzane `K_E` i `K_H` .</span><span class="sxs-lookup"><span data-stu-id="4bcc4-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="4bcc4-123">Modyfikator klucza jest 128-bitowym ciągiem losowo generowanym dla każdego wywołania do `Encrypt` i służy do zagwarantowania, że założenie, że funkcja KE i KH jest unikatowa dla tej operacji szyfrowania uwierzytelniania, nawet jeśli wszystkie inne dane wejściowe KDF są stałe.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="4bcc4-124">W przypadku operacji sprawdzania poprawności szyfrowania w trybie CBC + HMAC, `| K_E |` to długość klucza szyfrowania symetrycznego i `| K_H |` jest rozmiarem podsumowania procedury HMAC.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="4bcc4-125">W przypadku operacji szyfrowania GCM i walidacji `| K_H | = 0` .</span><span class="sxs-lookup"><span data-stu-id="4bcc4-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="4bcc4-126">CBC-Mode Encryption + Walidacja HMAC</span><span class="sxs-lookup"><span data-stu-id="4bcc4-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="4bcc4-127">Po `K_E` wygenerowaniu za pomocą powyższego mechanizmu generujemy losowy wektor inicjalizacji i uruchamiamy algorytm szyfrowania bloku symetrycznego, aby szyfrowanie zwykły tekst.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="4bcc4-128">Wektor inicjalizacji i tekst szyfrowany są następnie uruchamiane za pomocą procedury HMAC, która została zainicjowana przy użyciu klucza `K_H` w celu utworzenia komputera Mac.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="4bcc4-129">Ten proces i wartość zwracana są reprezentowane graficznie poniżej.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-129">This process and the return value is represented graphically below.</span></span>

![Proces CBC i powrót](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="4bcc4-131">`IDataProtector.Protect`Implementacja zwróci [nagłówek Magic i identyfikator klucza](xref:security/data-protection/implementation/authenticated-encryption-details) do danych wyjściowych przed przywróceniem go do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="4bcc4-132">Ponieważ nagłówek Magic i identyfikator klucza są niejawnie częścią usługi [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)i ponieważ modyfikator klucza jest podawany jako dane wejściowe do KDF, oznacza to, że każdy pojedynczy bajt końcowego zwróconego ładunku jest uwierzytelniany przez komputery Mac.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="4bcc4-133">Szyfrowanie w trybie Galois/licznik + Walidacja</span><span class="sxs-lookup"><span data-stu-id="4bcc4-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="4bcc4-134">Po `K_E` wygenerowaniu za pomocą powyższego mechanizmu generujemy losowo 96-bitowy identyfikator jednorazowy i uruchamiamy algorytm szyfrowania bloku symetrycznego, aby szyfrowanie zwykły tekst i utworzyć tag uwierzytelniania 128-bitowy.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proces GCM i powrót](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="4bcc4-136">Mimo że GCM natywnie obsługuje koncepcję usługi AAD, nadal będziemy uzyskiwać dostęp do usługi AAD tylko do oryginalnego KDF, ale w celu przekazania pustego ciągu do GCM dla jego parametru AAD.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="4bcc4-137">Przyczyną tego jest złożenie dwóch.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-137">The reason for this is two-fold.</span></span> <span data-ttu-id="4bcc4-138">Po pierwsze, [Aby obsługiwać elastyczność](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) , nigdy nie chcemy używać `K_M` bezpośrednio jako klucza szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="4bcc4-139">Ponadto GCM nakładają na dane wejściowe bardzo rygorystyczne wymagania unikatowości.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="4bcc4-140">Prawdopodobieństwo wywołania procedury szyfrowania GCM w dwóch lub większej liczbie odrębnych zestawów danych wejściowych o tej samej parze (Key, nonce) nie może przekroczyć 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="4bcc4-141">Jeśli firma Microsoft naprawi `K_E` , nie możemy wykonać więcej niż 2 ^ 32 operacji szyfrowania przed uruchomieniem afoul limitu 2 ^-32.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="4bcc4-142">Może to wyglądać podobnie do bardzo dużej liczby operacji, ale serwer sieci Web o wysokim natężeniu ruchu może przechodzić przez 4 000 000 000 żądań w zwykłych dniach, a także w normalnym okresie istnienia tych kluczy.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="4bcc4-143">Aby zachować zgodność z 2-32 ograniczeniem prawdopodobieństwa, będziemy nadal używać modyfikatora klucza 128-bitowego i 96-bitowy identyfikator jednorazowy, który radykalnie rozszerza liczbę operacji przydatnych dla danego elementu `K_M` .</span><span class="sxs-lookup"><span data-stu-id="4bcc4-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="4bcc4-144">W celu uproszczenia projektowania udostępnimy ścieżkę kodu KDF między operacjami CBC i GCM, a ponieważ usługa AAD jest już brana pod uwagę w KDF, nie ma potrzeby przechodzenia do procedury GCM.</span><span class="sxs-lookup"><span data-stu-id="4bcc4-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
